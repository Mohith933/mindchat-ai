<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MindChat AI ‚Äî Memory Companion (Step 5)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f6f7fb;
      --text: #111827;
      --accent: #7b5cff;
      --muted: #eef0fb;
      --error: #ff5c77; /* Added for visual clarity */
    }

    @media(prefers-color-scheme:dark) {
      :root {
        --bg: #0c0c10;
        --text: #eef2ff;
        --accent: #a58dff;
        --muted: #121217;
        --error: #ff8c99; /* Added for visual clarity */
      }
    }

    * {
      box-sizing: border-box;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      margin: 0;
      padding: 0;
    }
body {
  background: var(--bg);
  color: var(--text);
  overflow-x: hidden;
  overflow-y: auto; 
  display: block;   
}

   .sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 260px;
  height: 100vh;
  background: var(--muted);
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  overflow-y: auto;
  transition: transform 0.3s ease-in-out; /* Added for mobile toggle */
}

    .sidebar h2 {
      color: var(--accent);
      font-size: 1.1rem;
    }

    .sessions {
      flex: 1;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .session-item {
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
      border: 1px solid rgba(0, 0, 0, 0.03);
    }

    .session-item.active {
      background: linear-gradient(90deg, var(--accent), #b993ff);
      color: #fff;
    }

    .controls {
      display: flex;
      gap: 8px;
    }

    .btn {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn.ghost {
      background: transparent;
      color: var(--text);
      border: 1px solid rgba(0, 0, 0, 0.06);
      font-weight: 600;
    }

    .small {
      padding: 6px 8px;
      font-size: 0.9rem;
    }

    .main {
  margin-left: 260px;  
  margin-right: 340px; 
  border-left: 1px solid rgba(0, 0, 0, 0.04);
  border-right: 1px solid rgba(0, 0, 0, 0.04);
  width: calc(100% - 600px);
}

    .header {
      width: 100%;
      height:80px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 22px;
      background: var(--bg);
      color: var(--text);
      position: sticky;
      top:0;
      z-index: 5; /* Ensure header stays on top */
    }

    .header h1 {
      color: var(--accent);
      font-size: 1.2rem;
    }

.container {
  display: flex;
  flex: 1;
  gap: 12px;
  padding: 16px;
  overflow: visible; 
  height: auto;
}


.chat-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: transparent;
  height: calc(100vh - 120px); 
}

.chat-window {
  flex: 1;
  padding: 18px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  scroll-behavior: smooth;
  overflow-y: auto; /* Ensure chat window scrolls */
}

.input-area {
  flex-shrink: 0;
  display: flex;
  gap: 10px;
  padding: 5px;
  border-top: 1px solid rgba(0, 0, 0, 0.03);
  background: var(--bg);
  position: sticky;
  bottom: 0; 
}


    .message {
      max-width: 72%;
      padding: 10px 14px;
      border-radius: 12px;
      line-height: 1.45;
      font-size: 15px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.04);
    }

    .message.user {
      align-self: flex-end;
      background: var(--accent);
      color: #fff;
    }

    .message.ai {
      align-self: flex-start;
      background: var(--muted);
      border: 1px solid rgba(0, 0, 0, 0.06);
    }

    .meta {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 6px;
    }

    .input-area input {
      flex: 1;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(0, 0, 0, 0.06);
      outline: none;
      background: var(--bg); /* Ensure input background respects theme */
      color: var(--text);
    }

    .input-area button {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
    }

    .side-graph {
  position: fixed;
  top: 0;
  right: 0;
  width: 340px;
  height: 100vh;
  padding: 18px;
  background: var(--muted);
  border-radius: 0;
  display: flex;
  flex-direction: column;
  gap: 12px;
  overflow-y: auto;
  transition: transform 0.3s ease-in-out; /* Added for mobile toggle */
    }
    .graph-canvas {
      background: #fff;
      border-radius: 10px;
      width: 100%;
      height: 360px;
      display: block;
      border: 1px solid rgba(0, 0, 0, 0.04);
    }

    .tooltip {
      position: absolute;
      background: #111;
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity .12s;
      z-index: 100;
    }

    .controls-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .clear-btn {
      background: var(--error);
      color: #fff;
      border: 1px solid var(--error);
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
    }
    
    .clear-btn.small {
        font-weight: 600;
    }

    .clear-btn:hover {
      opacity: 0.9;
    }


    /* Mobile-first adjustments */
@media (max-width: 767px) {
  
  .sidebar {
    position: fixed;
    width: 80%;
    transform: translateX(-100%); /* Hidden by default */
    z-index: 20;
    display: flex; /* Override display:none */
  }
  
  .sidebar.active {
    transform: translateX(0); /* Shown when active */
  }

    .header {
    height: auto;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    padding: 8px 14px;
    background: var(--bg);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    position: sticky;
    top: 0;
    z-index: 10;
  }
  .side-graph {
    position: fixed;
    width: 80%;
    left: auto;
    right: 0;
    transform: translateX(100%); /* Hidden by default */
    z-index: 20;
    display: flex; /* Override display:none */
  }
  
  .side-graph.active {
    transform: translateX(0); /* Shown when active */
  }
   
  .header h1 {
    font-size: 1.1rem;
    text-align: center;
    flex: 1;
    margin: 0 10px;
  }
  .chat-window{
  padding-left:10px;
  padding-right:10px;
  gap:16px;
  }
  
  .main {
    margin-left: 0;
    margin-right: 0;
    width: 100%;
    padding: 0; /* Let chat-window handle padding */
  }

  .message {
    max-width: 90%;
    font-size: 0.95rem;
    line-height: 1.4;
    padding: 10px 14px;
    border-radius: 12px;
  }

  .input-area {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    padding: 10px;
    background: var(--bg);
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    z-index: 10;
  }

  .send-btn {
    font-size: 0.9rem;
    padding: 8px 14px;
    border-radius: 10px;
  }

  .small-muted {
    font-size: 11px;
    opacity: 0.65;
  }
}

  </style>
</head>

<body> 
  <div class="sidebar" aria-label="Sessions and memory controls">
    <h2>üß† Sessions</h2>
    <div class="controls">
      <button id="newSessionBtn" class="btn small">Ôºã New</button>
      <button id="saveSessionBtn" class="btn small">Save</button>
    </div>
    <div class="sessions" id="sessionsList" aria-live="polite">
      </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="exportBtn" class="btn small ghost">Export Chat (.txt)</button>
      <button id="clearMemoryBtn" class="clear-btn small">üßπ Clear ALL</button>
    </div>
    <div class="small-muted">Memory nodes & links persist locally. Clear will remove them.</div>
  </div> 

  <div class="main">
    <div class="header">
      <div class="controls-row">
        <button id="toggleSidebar">‚ò∞</button>
        <h1>MindChat AI ‚Äî Memory Companion</h1>
      </div>
      <div class="controls-row">
        <button id="toggleGraph">üï∏</button>
        <div id="typingIndicator" class="small-muted"></div>
      </div>
    </div>

    <div class="container">
      <div class="chat-area" role="main">
        <div id="chatWindow" class="chat-window" aria-live="polite">
          </div>
        <div class="input-area">
          <input id="userInput" placeholder="Type your thought... (Ctrl+Enter to send)" aria-label="Type your thought">
          <button id="sendBtn" class="send-btn">Send</button>
        </div>
      </div>

      <div class="side-graph" aria-label="Memory graph">
        <h3 style="margin:0;color:var(--accent)">üï∏ Memory Graph (Emotional Layer)</h3>
        <canvas id="graphCanvas" class="graph-canvas" width="640" height="480"></canvas>
        <div style="display:flex; gap:8px;">
          <button id="clearGraphBtn" class="clear-btn small">üßπ Clear Graph</button>
          <button id="saveNodesBtn" class="btn small ghost">Save Nodes</button>
          <button id="downloadGraphBtn" class="btn small ghost">Export JSON</button> </div>
        <div id="tooltip" class="tooltip" aria-hidden="true"></div>
      </div>

    </div>
  </div>
  <script>
    /* ------------------------------      
      MindChat Step 5 ‚Äî Final JS (Corrected)      
      -------------------------------*/

    const chatWindow = document.getElementById('chatWindow');
    const userInput = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    const typingIndicator = document.getElementById('typingIndicator');
    const exportBtn = document.getElementById('exportBtn');

    const graphCanvas = document.getElementById('graphCanvas');
    const ctx = graphCanvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');

    const sessionsListEl = document.getElementById('sessionsList');
    const newSessionBtn = document.getElementById('newSessionBtn');
    const saveSessionBtn = document.getElementById('saveSessionBtn');
    const clearGraphBtn = document.getElementById('clearGraphBtn');
    const downloadGraphBtn = document.getElementById('downloadGraphBtn'); // Defined button element
    const saveNodesBtn = document.getElementById('saveNodesBtn');
    
    // --- Global State ---
    let typingTimeout = null; // ‚úÖ FIXED: Declared typingTimeout
    let lastMood = null;
    let lastReply = null;
    
    const STORAGE = {
      nodes: 'mindchat_nodes_v4',
      links: 'mindchat_links_v4',
      sessions: 'mindchat_sessions_v4',
      activeSessionId: 'mindchat_active_session_v4',
      messages: 'mindchat_messages_v4'      
    };

    // in-memory data      
    let nodes = JSON.parse(localStorage.getItem(STORAGE.nodes) || '[]');
    let links = JSON.parse(localStorage.getItem(STORAGE.links) || '[]');
    let sessions = JSON.parse(localStorage.getItem(STORAGE.sessions) || '[]'); 
    let messages = JSON.parse(localStorage.getItem(STORAGE.messages) || '[]'); 
    let activeSession = localStorage.getItem(STORAGE.activeSessionId) || null;

    /* ---------------- Helpers ---------------- */
    function nowPretty() { return new Date().toLocaleString(); }
    function uid(prefix = 'id') { return prefix + '_' + Math.random().toString(36).slice(2, 9); }
    function saveNodes() { localStorage.setItem(STORAGE.nodes, JSON.stringify(nodes)); }
    function saveLinks() { localStorage.setItem(STORAGE.links, JSON.stringify(links)); }
    function saveSessions() { localStorage.setItem(STORAGE.sessions, JSON.stringify(sessions)); }
    function saveMessages() { localStorage.setItem(STORAGE.messages, JSON.stringify(messages)); }
    function setActiveSession(id) {
      activeSession = id;
      localStorage.setItem(STORAGE.activeSessionId, id);
      renderSessions();
      renderMessages();
    }

    // --- Mobile toggle buttons ---
    const sidebar = document.querySelector('.sidebar');
    const graph = document.querySelector('.side-graph');
    document.getElementById('toggleSidebar').addEventListener('click', () => {
      sidebar.classList.toggle('active');
      graph.classList.remove('active'); // Close graph when opening sidebar
    });
    document.getElementById('toggleGraph').addEventListener('click', () => {
      graph.classList.toggle('active');
      sidebar.classList.remove('active'); // Close sidebar when opening graph
    });

    /* ------------- Sessions UI ------------- */
    function renderSessions() {
      sessionsListEl.innerHTML = '';
      if (sessions.length === 0) {
        const div = document.createElement('div');
        div.className = 'session-item';
        div.textContent = 'No saved sessions ‚Äî create one';
        sessionsListEl.appendChild(div);
        return;
      }
      sessions.forEach(s => {
        const el = document.createElement('div');
        el.className = 'session-item' + (s.id === activeSession ? ' active' : '');
        el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">      
      <div><strong>${s.name}</strong><div style="font-size:12px;opacity:.7">${new Date(s.ts).toLocaleString()}</div></div>      
      <div style="display:flex;gap:6px">      
        <button class="btn ghost small" data-load="${s.id}">Load</button>      
        <button class="btn ghost small" data-del="${s.id}">Del</button>      
      </div>      
    </div>`;
        sessionsListEl.appendChild(el);
      });
    }

    // New session      
    newSessionBtn.addEventListener('click', () => {
      const name = prompt('Session name (optional)') || 'Session ' + new Date().toLocaleString();
      const id = uid('sess');
      const s = { id, name, ts: Date.now(), messages: [] }; // initialize with empty messages
      sessions.unshift(s);
      saveSessions();
      messages = [];
      saveMessages();
      setActiveSession(id);
      chatWindow.innerHTML = '';
    });

    // Save current session (store messages snapshot)      
    saveSessionBtn.addEventListener('click', () => {
      if (!activeSession) {
        alert('Create or load a session first (press New).');
        return;
      }
      // attach messages snapshot to session object for quick restore      
      sessions = sessions.map(s => {
        if (s.id === activeSession) {
          return { ...s, messages: messages.slice(), ts: Date.now() };
        }
        return s;
      });
      saveSessions();
      alert('Session saved locally ‚úì');
      renderSessions();
    });

    // Listen session actions (load/delete)      
    sessionsListEl.addEventListener("click", (ev) => {
      const loadId = ev.target.dataset.load;
      const delId = ev.target.dataset.del;

      // ‚úÖ FIXED: Session item click fallback (not on load/del buttons)
      if (!loadId && !delId && ev.target.closest('.session-item')) { 
        const sId = ev.target.closest('.session-item').querySelector('[data-load]')?.dataset.load;
        if (sId) {
            const s = sessions.find(x => x.id === sId);
            if (!s) return;
            messages = s.messages ? s.messages.slice() : [];
            saveMessages();
            setActiveSession(sId);
            renderMessages();
            requestAnimationFrame(() => chatWindow.scrollTop = chatWindow.scrollHeight);
        }
    }

      // ‚úÖ LOAD
      if (loadId) {
        const s = sessions.find((x) => x.id === loadId);
        if (!s) return;
        messages = s.messages ? s.messages.slice() : [];
        saveMessages();
        setActiveSession(loadId);
        renderMessages(); 
        setTimeout(() => chatWindow.scrollTop = chatWindow.scrollHeight, 50);
        return;
      }

      // ‚úÖ DELETE
      if (delId) {
        if (!confirm("Delete this session?")) return;
        sessions = sessions.filter((x) => x.id !== delId);
        saveSessions();
        if (activeSession === delId) {
          activeSession = null;
          localStorage.removeItem(STORAGE.activeSessionId);
          messages = [];
          saveMessages();
          chatWindow.innerHTML = "";
        }
        renderSessions();
        return;
      }
    });

    // ‚úÖ clear ALL memory from sidebar button
    document.getElementById("clearMemoryBtn").addEventListener("click", () => {
      if (!confirm("‚ö†Ô∏è Clear ALL sessions, messages, nodes, and links?")) return;
      // wipe everything
      localStorage.clear(); // Simpler way to clear all MindChat storage
      
      // reset runtime data
      nodes = [];
      links = [];
      sessions = [];
      messages = [];
      activeSession = null;

      // refresh UI
      chatWindow.innerHTML = "";
      renderSessions();
      drawGraph(); // Will continue animation but with empty data
      alert("üßπ All MindChat memory cleared!");
    });


    /* -------------- Chat UI -------------- */
    function appendMessage(text, who, ts) {
      const el = document.createElement('div');
      el.className = 'message ' + (who === 'user' ? 'user' : 'ai');
      el.innerHTML = `<div>${escapeHtml(text)}</div><div class="meta">${who === 'user' ? 'You' : 'MindChat AI'} ‚Ä¢ ${new Date(ts).toLocaleTimeString()}</div>`;
      chatWindow.appendChild(el);
      // force scroll to bottom
      requestAnimationFrame(() => {
        chatWindow.scrollTop = chatWindow.scrollHeight;
      });
    }

    // Safe text -> HTML      
    function escapeHtml(s) {
      return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

   function detectMood(text) {
  text = text.toLowerCase();
  if (text.includes("sad") || text.includes("tired") || text.includes("lonely") || text.includes("depressed"))
    return "sad";
  if (text.includes("happy") || text.includes("excited") || text.includes("great") || text.includes("joy"))
    return "happy";
  if (text.includes("angry") || text.includes("mad") || text.includes("annoyed") || text.includes("frustrated"))
    return "angry";
  if (text.includes("love") || text.includes("like") || text.includes("crush") || text.includes("heart") || text.includes("cherish"))
    return "love";
  return "neutral";
}

function generateAIReply(userText) {
  const mood = detectMood(userText);
  const replies = {
    happy: [
      "I love that energy! Tell me more about what made you smile üòÑ",
      "That‚Äôs wonderful ‚Äî it‚Äôs nice to hear your mood is bright!",
      "Good vibes! What are you most thankful for today?"
    ],
    sad: [
      "I'm here with you. Want to talk about what made you feel this way? ü´Ç",
      "It‚Äôs okay to feel down sometimes ‚Äî what could help you right now?",
      "That sounds heavy, but you‚Äôre not alone üåô"
    ],
    angry: [
      "I sense frustration ‚Äî want to unpack what triggered it?",
      "It‚Äôs okay to feel angry, expressing it helps you heal.",
      "Let‚Äôs slow down and take a breath together. üßò"
    ],
    love: [
      "Aww, that‚Äôs sweet ‚Äî love always makes the world brighter üíû",
      "Who‚Äôs on your mind right now?",
      "That‚Äôs lovely. What do you cherish most about that person?"
    ],
    neutral: [
      "I‚Äôm listening carefully ‚Äî tell me more.",
      "That‚Äôs interesting. How do you feel about it?",
      "I‚Äôm linking this with your last thought in memory üß†"
    ]
  };

  const group = replies[mood];
  let reply;

  // choose a new reply different from the last one
  do {
    reply = group[Math.floor(Math.random() * group.length)];
  } while (reply === lastReply && group.length > 1);

  lastReply = reply;
  lastMood = mood;
  return reply;
}

function setTyping(on) {
  typingIndicator.textContent = on ? "MindChat is typing‚Ä¶" : "";
}

/* ------------- Message send flow ------------- */
async function sendMessage() {
  const text = userInput.value.trim();
  if (!text) return;

  const ts = Date.now();
  messages.push({ who: 'user', text, ts });
  saveMessages();
  appendMessage(text, 'user', ts);
  addNodeToGraph(text, 'user', ts);
  userInput.value = '';

  setTyping(true);

  const delay = 600 + Math.floor(Math.random() * 600);
  clearTimeout(typingTimeout);

  typingTimeout = setTimeout(() => {
    const reply = generateAIReply(text);
    const ts2 = Date.now();

    messages.push({ who: 'ai', text: reply, ts: ts2 });
    saveMessages();
    appendMessage(reply, 'ai', ts2);
    addNodeToGraph(reply, 'ai', ts2);
    setTyping(false);
  }, delay);
}

sendBtn.addEventListener('click', sendMessage);
userInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.ctrlKey) {
        sendMessage();
    }
});


    /* ---------------- Graph logic (Emotional Layer) ---------------- */
    
    // Basic sentiment estimation (light heuristic)
    function analyzeEmotion(text) {
      const positive = ['love', 'happy', 'joy', 'beautiful', 'great', 'like', 'peace', 'calm', 'hope', 'smile', 'excited', 'wonderful'];
      const negative = ['sad', 'hate', 'angry', 'pain', 'cry', 'fear', 'bad', 'hurt', 'lonely', 'tired', 'mad', 'annoyed', 'frustrated'];
      let score = 0;
      text.toLowerCase().split(/\s+/).forEach(w => {
        if (positive.includes(w)) score += 1;
        if (negative.includes(w)) score -= 1;
      });
      return Math.max(-3, Math.min(3, score)); // clamp -3 to +3
    }
    
    const STOP = new Set(['the', 'and', 'a', 'i', 'to', 'of', 'in', 'on', 'for', 'is', 'it', 'that', 'this', 'with', 'my', 'you', 'me', 'be', 'im', 'am']);
    function extractKeywords(text) {
      return text.toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .split(/\s+/)
        .filter(w => w.length > 2 && !STOP.has(w))
        .slice(0, 6);
    }
    
    function addNodeToGraph(text, type, ts) {
      const emotion = analyzeEmotion(text);
      const KW = extractKeywords(text);
      // place node near center jitter      
      const x = 30 + Math.random() * (graphCanvas.width - 60);
      const y = 30 + Math.random() * (graphCanvas.height - 60);
      
      // hue shift by emotion: 240 (blue/neutral) +/- (emotion * 20)
      const hueShift = 240 + (emotion * 20); 
      const nodeColor = `hsl(${hueShift}, 85%, 55%)`; // reduced saturation/lightness for dark theme contrast
      
      const node = { id: uid('n'), text, ts, x, y, color: nodeColor, dx: (Math.random() - .5) * 1.2, dy: (Math.random() - .5) * 1.2, keywords: KW, emotion };

      // link heuristics: link to recent nodes with shared keywords (max 3)      
      const matches = nodes.filter(n => n.keywords.some(k => KW.includes(k)));
      const toLink = matches.slice(-3);
      nodes.push(node);
      toLink.forEach(m => links.push({ a: m.id, b: node.id }));
      
      // always link to last node if no keyword matches (continuity)      
      if (toLink.length === 0 && nodes.length > 1) {
        links.push({ a: nodes[nodes.length - 2].id, b: node.id });
      }
      saveNodes(); saveLinks();
      // Don't call drawGraph here, let the animation frame loop handle it
    }

    /* ---------------- Graph draw + animation ---------------- */
    function drawGraph() {
      // Handle canvas resize on high-DPI screens if needed, but keeping simple for now
      ctx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

      // gentle physics movement      
      nodes.forEach(n => {
        // Friction and boundary check
        n.dx *= 0.99; n.dy *= 0.99;
        n.x += (n.dx || 0);
        n.y += (n.dy || 0);
        
        // clamp      
        if (n.x < 12) { n.x = 12; n.dx = Math.abs(n.dx) * 0.9; }
        if (n.x > graphCanvas.width - 12) { n.x = graphCanvas.width - 12; n.dx = -Math.abs(n.dx) * 0.9; }
        if (n.y < 12) { n.y = 12; n.dy = Math.abs(n.dy) * 0.9; }
        if (n.y > graphCanvas.height - 12) { n.y = graphCanvas.height - 12; n.dy = -Math.abs(n.dy) * 0.9; }
      });

      // draw links by resolving ids to nodes      
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(123,92,255,0.22)';
      links.forEach(l => {
        const a = nodes.find(n => n.id === l.a);
        const b = nodes.find(n => n.id === l.b);
        if (!a || !b) return;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      });

      // emotional nodes
      nodes.forEach(n => {
        ctx.beginPath();
        const intensity = Math.abs(n.emotion || 0);
        const size = 6 + intensity * 1.5; // bigger = stronger emotion
        ctx.fillStyle = n.color || '#b8a6ff';
        ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
        ctx.fill();

        // soft glow for strong emotions
        if (intensity > 1) {
          const grd = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, size * 2);
          grd.addColorStop(0, n.color.replace(/, 55%\)/, ', 75%)')); // Brighter center glow
          grd.addColorStop(1, 'transparent');
          ctx.fillStyle = grd;
          ctx.beginPath(); ctx.arc(n.x, n.y, size * 2, 0, Math.PI * 2); ctx.fill();
        }
      });

      requestAnimationFrame(drawGraph);
    }

    /* tooltip hover */
    graphCanvas.addEventListener('mousemove', (ev) => {
      const rect = graphCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      let found = null;
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i];
        const dx = x - n.x;
        const dy = y - n.y;
        if (Math.sqrt(dx * dx + dy * dy) < 10) { found = n; break; } // Increased hit area
      }
      if (found) {
        // Adjust position relative to the graph canvas for fixed positioning
        tooltip.style.left = (rect.left + x + 12) + 'px';
        tooltip.style.top = (rect.top + y + 12) + 'px';
        tooltip.innerText = `[${found.emotion > 0 ? 'Positive' : found.emotion < 0 ? 'Negative' : 'Neutral'}] ${found.text.slice(0, 180)}`;
        tooltip.style.opacity = 1;
      } else {
        tooltip.style.opacity = 0;
      }
    });

    /* canvas click: focus message or open detail (optional) */
    graphCanvas.addEventListener('click', (ev) => {
      const rect = graphCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i];
        const dx = x - n.x, dy = y - n.y;
        if (Math.sqrt(dx * dx + dy * dy) < 10) {
          messages.push({ who: 'ai', text: 'I recall this memory: "' + n.text.slice(0, 120) + '"', ts: Date.now() });
          saveMessages();
          appendMessage('I recall this memory: "' + n.text.slice(0, 120) + '"', 'ai', Date.now());
          return;
        }
      }
    });

    /* --------------- Export / clear / save actions --------------- */
    exportBtn.addEventListener('click', () => {
        const lines = messages.map(m => {
          const who = m.who === 'user' ? 'You' : 'MindChat AI';
          return `[${new Date(m.ts).toLocaleString()}] ${who}: ${m.text}`;
        }).join('\n\n');

        if (!lines || messages.length <= 1) { // Check for just the greeting
          alert("No significant messages to export!");
          return;
        }

        const blob = new Blob([lines], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `MindChat_Transcript_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    });

    clearGraphBtn.addEventListener('click', () => {
      if (!confirm('Clear all memory nodes, links, and saved nodes from graph? (This does not affect chat sessions).')) return;
      nodes = []; links = []; saveNodes(); saveLinks();
      alert('Graph Memory cleared.');
    });

    downloadGraphBtn.addEventListener('click', () => {
      const data = { nodes, links, ts: Date.now() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'mindchat_graph_' + (new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')) + '.json';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    saveNodesBtn.addEventListener('click', () => {
      saveNodes(); saveLinks();
      alert('Nodes & links saved to localStorage ‚úì');
    });

    /* -------------- Messages load/render at start -------------- */
    function renderMessages() {
      chatWindow.innerHTML = '';
      if (!messages || messages.length === 0 || !activeSession) {
        const welcomeText = 'Hello üëã I‚Äôm MindChat AI, your memory companion. What‚Äôs on your mind today?';
        messages = [{ who: 'ai', text: welcomeText, ts: Date.now() }];
        // Only save initial message if a session is active
        if (activeSession) saveMessages(); 
      }
      messages.forEach(m => appendMessage(m.text, m.who, m.ts));
      // Ensure scroll on load
      setTimeout(() => chatWindow.scrollTop = chatWindow.scrollHeight, 100);
    }

    /* -------------- initial render -------------- */
    // Ensure nodes have 'emotion' field if loaded from older storage
    nodes = nodes.map(n => ({...n, emotion: n.emotion || analyzeEmotion(n.text)})); 
    
    renderSessions();
    if (!activeSession && sessions.length > 0) {
      setActiveSession(sessions[0].id);
    } else if (!activeSession) {
        // Create a default session if none exist
        const defaultSessionId = uid('sess');
        const defaultSession = { id: defaultSessionId, name: 'Default Session', ts: Date.now(), messages: [] };
        sessions.push(defaultSession);
        saveSessions();
        setActiveSession(defaultSessionId);
    }
    renderMessages();
    requestAnimationFrame(drawGraph);
  </script>
</body>
</html>
