<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MindChat AI ‚Äî Memory Companion (Page Scrolling)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f6f7fb;
      --text: #111827;
      --accent: #7b5cff;
      --muted: #eef0fb;
      --error: #ff5c77;
    }

    @media(prefers-color-scheme:dark) {
      :root {
        --bg: #0c0c10;
        --text: #eef2ff;
        --accent: #a58dff;
        --muted: #121217;
        --error: #ff8c99;
      }
    }

    * {
      box-sizing: border-box;
      font-family: Poppins;
      margin: 0;
      padding: 0;
    }
body {
  background: var(--bg);
  color: var(--text);
  /* ‚ö†Ô∏è KEY CHANGE: Allow body to scroll content */
  overflow-x: hidden; 
  display: block;   
  min-height: 100vh; /* Optional, just for minimum visual height */
}

   .sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 260px;
  /* ‚ö†Ô∏è KEY CHANGE: Changed from 100vh to ensure it stays fixed */
  height: 100%; 
  background: var(--muted);
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  overflow-y: auto;
  transition: transform 0.3s ease-in-out;
}

    .sidebar h2 {
      color: var(--accent);
      font-size: 1.1rem;
    }

    .sessions {
      flex: 1;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .session-item {
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
      border: 1px solid rgba(0, 0, 0, 0.03);
    }

    .session-item.active {
      background: linear-gradient(90deg, var(--accent), #b993ff);
      color: #fff;
    }

    .controls {
      display: flex;
      gap: 8px;
    }

    .btn {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn.ghost {
      background: transparent;
      color: var(--text);
      border: 1px solid rgba(0, 0, 0, 0.06);
      font-weight: 600;
    }

    .small {
      padding: 6px 8px;
      font-size: 0.9rem;
    }

    .main {
  margin-left: 260px;  
  margin-right: 340px; 
  border-left: 1px solid rgba(0, 0, 0, 0.04);
  border-right: 1px solid rgba(0, 0, 0, 0.04);
  /* ‚ö†Ô∏è KEY CHANGE: Allow main content to grow */
  width: calc(100% - 600px); 
  min-height: 100vh; /* Ensure full visible height */
}

    .header {
      width: 100%;
      height: 80px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 22px;
      background: var(--bg);
      color: var(--text);
      position: sticky;
      top: 0;
      z-index: 5;
    }

    .header h1 {
      color: var(--accent);
      font-size: 1.2rem;
    }

.container {
  display: flex;
  flex: 1;
  gap: 12px;
  padding: 16px;
  overflow: visible; 
  /* ‚ö†Ô∏è KEY CHANGE: Set min-height to push content down */
  min-height: calc(100vh - 80px); 
}


#toggleSidebar{
  display:none;
}
#toggleGraph{
  display:none;
}

.chat-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: transparent;
  /* ‚ö†Ô∏è KEY CHANGE: Removed fixed height to allow vertical growth */
  height: auto; 
}

.chat-window {
  flex: 1;
  padding: 18px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  scroll-behavior: smooth;
  /* ‚ö†Ô∏è KEY CHANGE: Removed overflow auto/scroll to allow content to push the page */
  overflow-y: visible; 
  min-height: 200px; /* Minimum visual height */
}

.input-area {
  flex-shrink: 0;
  display: flex;
  gap: 10px;
  padding: 5px;
  border-top: 1px solid rgba(0, 0, 0, 0.03);
  background: var(--bg);
  /* ‚ö†Ô∏è KEY CHANGE: Changed from sticky/fixed to relative so it scrolls with content */
  position:sticky; 
  bottom: 0; 
}


    .message {
      max-width: 72%;
      padding: 10px 14px;
      border-radius: 12px;
      line-height: 1.45;
      font-size: 15px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.04);
    }

    .message.user {
      align-self: flex-end;
      background: var(--accent);
      color: #fff;
    }

    .message.ai {
      align-self: flex-start;
      background: var(--muted);
      border: 1px solid rgba(0, 0, 0, 0.06);
    }

    .meta {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 6px;
    }

    .input-area input {
      flex: 1;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(0, 0, 0, 0.06);
      outline: none;
      background: var(--bg);
      color: var(--text);
    }

    .input-area button {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
    }

    .side-graph {
  position: fixed;
  top: 0;
  right: 0;
  width: 340px;
  /* ‚ö†Ô∏è KEY CHANGE: Changed from 100vh to ensure it stays fixed */
  height: 100%; 
  padding: 18px;
  background: var(--muted);
  border-radius: 0;
  display: flex;
  flex-direction: column;
  gap: 12px;
  overflow-y: auto;
  transition: transform 0.3s ease-in-out;
    }
    .graph-canvas {
      background: #fff;
      border-radius: 10px;
      width: 100%;
      height: 360px;
      display: block;
      border: 1px solid rgba(0, 0, 0, 0.04);
    }

    .tooltip {
      position: absolute;
      background: #111;
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity .12s;
      z-index: 100;
    }

    .controls-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .clear-btn {
      background: var(--error);
      color: #fff;
      border: 1px solid var(--error);
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
    }
    
    .clear-btn.small {
        font-weight: 600;
    }

    .clear-btn:hover {
      opacity: 0.9;
    }



    /* Mobile-first adjustments */
@media (max-width: 1000px) {
  
  .sidebar {
    position: fixed;
    width: 80%;
    transform: translateX(-100%);
    z-index: 20;
    display: flex;
  }
  
  .sidebar.active {
    transform: translateX(0);
  }

    .header {
    height: auto;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    padding: 8px 14px;
    background: var(--bg);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    position: sticky;
    top: 0;
    z-index: 10;
  }
  .side-graph {
    position: fixed;
    width: 80%;
    left: auto;
    right: 0;
    transform: translateX(100%);
    z-index: 20;
    display: flex;
  }
  
  .side-graph.active {
    transform: translateX(0);
  }

  #toggleSidebar{
  display:flex;
}
#toggleGraph{
  display:flex;
}
   
  .header h1 {
    font-size: 1.1rem;
    text-align: center;
    flex: 1;
    margin: 0 10px;
  }
  .chat-window{
  padding-left:10px;
  padding-right:10px;
  gap:16px;
  }
  
  .main {
    margin-left: 0;
    margin-right: 0;
    width: 100%;
    padding: 0;
  }

  .message {
    max-width: 90%;
    font-size: 0.95rem;
    line-height: 1.4;
    padding: 10px 14px;
    border-radius: 12px;
  }

  .input-area {
    /* ‚ö†Ô∏è KEY CHANGE: On mobile, input area still needs to be sticky/fixed to follow the viewport */
    position: fixed; 
    bottom: 0;
    left: 0;
    width: 100%;
    padding: 10px;
    background: var(--bg);
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    z-index: 10;
  }

  .send-btn {
    font-size: 0.9rem;
    padding: 8px 14px;
    border-radius: 10px;
  }

  .small-muted {
    font-size: 11px;
    opacity: 0.65;
  }
}
    

  </style>
</head>

<body> 
  <div class="sidebar" aria-label="Sessions and memory controls">
    <h2>üß† Sessions</h2>
    <div class="controls">
      <button id="newSessionBtn" class="btn small">Ôºã New</button>
      <button id="saveSessionBtn" class="btn small">Save</button>
    </div>
    <div class="sessions" id="sessionsList" aria-live="polite">
      </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="exportBtn" class="btn small ghost">Export Chat (.txt)</button>
      <button id="clearMemoryBtn" class="clear-btn small">üßπ Clear ALL</button>
    </div>
    <div class="small-muted">Memory nodes & links persist locally. Clear will remove them.</div>
  </div> 

  <div class="main">
    <div class="header">
      <div class="controls-row">
        <button id="toggleSidebar">‚ò∞</button>
        <h1>MindChat AI ‚Äî Memory Companion</h1>
      </div>
      <div class="controls-row">
        <button id="toggleGraph">üï∏</button>
      </div>
    </div>

    <div class="container">
      <div class="chat-area" role="main">
        <div id="chatWindow" class="chat-window" aria-live="polite">
          </div>
          <div id="typingIndicator" class="small-muted"></div>
        <div class="input-area">
          <input id="userInput" placeholder="Type your thought... (Ctrl+Enter to send)" aria-label="Type your thought">
          <button id="sendBtn" class="send-btn">Send</button>
        </div>
      </div>

      <div class="side-graph" aria-label="Memory graph">
        <h3 style="margin:0;color:var(--accent)">üï∏ Memory Graph (Emotional Layer)</h3>
        <canvas id="graphCanvas" class="graph-canvas" width="640" height="480"></canvas>
        <div style="display:flex; gap:8px;">
          <button id="clearGraphBtn" class="clear-btn small">üßπ Clear Graph</button>
          <button id="saveNodesBtn" class="btn small ghost">Save Nodes</button>
          <button id="downloadGraphBtn" class="btn small ghost">Export JSON</button>
        </div>
        <div id="tooltip" class="tooltip" aria-hidden="true"></div>
      </div>

    </div>
  </div>
  <script>
    /* ------------------------------      
      MindChat Step 5 ‚Äî Final JS (Corrected Toggle Logic)    
      -------------------------------*/


      // --- MEMORY ENGINE CORE (required) ---
let memoryGraph = [];

    // stores group ‚Üí [facts]
let memoryWeights = [];   // stores strength of each fact
let topNodes = [];        // most relevant memory keys
let recentFacts = [];     // optional: for trend detection
// v1.0 personal memory store
let personalMemory = {
  like: [],
  love: [],
  hate: [],
  favorite: {} // category ‚Üí item
};


    const chatWindow = document.getElementById('chatWindow');
    const userInput = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    const typingIndicator = document.getElementById('typingIndicator');
    const exportBtn = document.getElementById('exportBtn');

    const graphCanvas = document.getElementById('graphCanvas');
    const ctx = graphCanvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');

    const sessionsListEl = document.getElementById('sessionsList');
    const newSessionBtn = document.getElementById('newSessionBtn');
    const saveSessionBtn = document.getElementById('saveSessionBtn');
    const clearGraphBtn = document.getElementById('clearGraphBtn');
    const downloadGraphBtn = document.getElementById('downloadGraphBtn');
    const saveNodesBtn = document.getElementById('saveNodesBtn');
    
    // --- Global State ---
    let typingTimeout = null;
    let lastMood = null;
    let lastReply = null;

        /* ---------------- Personality Seeds ---------------- */
const personality = {
  warmth: 0.85,
  empathy: 0.92,
  humor: 0.4,
  optimism: 0.73,
  reflectiveness: 0.65
};


    const STORAGE = {
      nodes: 'mindchat_nodes_v4',
      links: 'mindchat_links_v4',
      sessions: 'mindchat_sessions_v4',
      activeSessionId: 'mindchat_active_session_v4',
      messages: 'mindchat_messages_v4'      
    };

    // in-memory data      
    let nodes = JSON.parse(localStorage.getItem(STORAGE.nodes) || '[]');
    let links = JSON.parse(localStorage.getItem(STORAGE.links) || '[]');
    let sessions = JSON.parse(localStorage.getItem(STORAGE.sessions) || '[]'); 
    let messages = JSON.parse(localStorage.getItem(STORAGE.messages) || '[]'); 
    let activeSession = localStorage.getItem(STORAGE.activeSessionId) || null;

    /* ---------------- Helpers ---------------- */
    function nowPretty() { return new Date().toLocaleString(); }
    function uid(prefix = 'id') { return prefix + '_' + Math.random().toString(36).slice(2, 9); }
    function saveNodes() { localStorage.setItem(STORAGE.nodes, JSON.stringify(nodes)); }
    function saveLinks() { localStorage.setItem(STORAGE.links, JSON.stringify(links)); }
    function saveSessions() { localStorage.setItem(STORAGE.sessions, JSON.stringify(sessions)); }
    function saveMessages() { localStorage.setItem(STORAGE.messages, JSON.stringify(messages)); }
    function setActiveSession(id) {
      activeSession = id;
      localStorage.setItem(STORAGE.activeSessionId, id);
      renderSessions();
      renderMessages();
    }

    // ‚≠ê Paste here
function saveSnapshot(graph) {
  const snapshot = {
    time: Date.now(),
    graph: graph
  };
  localStorage.setItem("mindchat_snapshot", JSON.stringify(snapshot));
}

function loadSnapshot() {
  const data = localStorage.getItem("mindchat_snapshot");
  return data ? JSON.parse(data) : null;
}

// compute simple similarity (token overlap)
function textSimilarity(a, b) {
  const A = new Set(a.toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/).filter(Boolean));
  const B = new Set(b.toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/).filter(Boolean));
  if (A.size === 0 || B.size === 0) return 0;
  let inter = 0;
  A.forEach(x => { if (B.has(x)) inter++; });
  return inter / Math.max(A.size, B.size);
}

// consolidate nodes that are very similar (threshold 0.6)
function consolidateMemoryNodes(threshold = 0.6) {
  const merged = [];
  const seen = new Set();

  for (let i = 0; i < nodes.length; i++) {
    if (seen.has(nodes[i].id)) continue;
    const base = {...nodes[i]};
    for (let j = i+1; j < nodes.length; j++) {
      if (seen.has(nodes[j].id)) continue;
      const sim = textSimilarity(base.text, nodes[j].text);
      if (sim >= threshold) {
        // merge weights, timestamps, keywords, emotion, importance
        base.importance = Math.min(1, Math.max(base.importance || 0, nodes[j].importance || 0));
        base.emotion = ((base.emotion||0) + (nodes[j].emotion||0)) / 2;
        base.keywords = Array.from(new Set([...(base.keywords||[]), ...(nodes[j].keywords||[])]));
        base.text = base.text.length >= nodes[j].text.length ? base.text : nodes[j].text;
        seen.add(nodes[j].id);
      }
    }
    merged.push(base);
    seen.add(nodes[i].id);
  }
  nodes = merged;
  saveNodes();
}


    // --- Mobile toggle buttons ---
    const sidebar = document.querySelector('.sidebar');
    const graph = document.querySelector('.side-graph');

    document.getElementById('toggleSidebar').addEventListener('click', (e) => {
      e.stopPropagation();
      sidebar.classList.toggle('active');
      graph.classList.remove('active');
    });

    document.getElementById('toggleGraph').addEventListener('click', (e) => {
      e.stopPropagation();
      graph.classList.toggle('active');
      sidebar.classList.remove('active');
    });

    // --- Prevent accidental closing when interacting inside ---
    sidebar.addEventListener('click', (e) => e.stopPropagation());
    graph.addEventListener('click', (e) => e.stopPropagation());

    // --- Close both when clicking outside ---
    document.addEventListener('click', (e) => {
      const isInsideSidebar = sidebar.contains(e.target);
      const isInsideGraph = graph.contains(e.target);
      const isToggleBtn = e.target.closest('#toggleSidebar, #toggleGraph');

      if (!isInsideSidebar && !isInsideGraph && !isToggleBtn) {
        sidebar.classList.remove('active');
        graph.classList.remove('active');
      }
    });

    /* ------------- Sessions UI ------------- */
    function renderSessions() {
      sessionsListEl.innerHTML = '';
      if (sessions.length === 0) {
        const div = document.createElement('div');
        div.className = 'session-item';
        div.textContent = 'No saved sessions ‚Äî create one';
        sessionsListEl.appendChild(div);
        return;
      }
      sessions.forEach(s => {
        const el = document.createElement('div');
        el.className = 'session-item' + (s.id === activeSession ? ' active' : '');
        el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">      
      <div><strong>${s.name}</strong><div style="font-size:12px;opacity:.7">${new Date(s.ts).toLocaleString()}</div></div>      
      <div style="display:flex;gap:6px">      
        <button class="btn ghost small" data-load="${s.id}">Load</button>      
        <button class="btn ghost small" data-del="${s.id}">Del</button>      
      </div>      
    </div>`;
        sessionsListEl.appendChild(el);
      });
    }

    // New session      
    newSessionBtn.addEventListener('click', () => {
      const name = prompt('Session name (optional)') || 'Session ' + new Date().toLocaleString();
      const id = uid('sess');
      const s = { id, name, ts: Date.now(), messages: [] };
      sessions.unshift(s);
      saveSessions();
      messages = [];
      saveMessages();
      setActiveSession(id);
      chatWindow.innerHTML = '';
    });

    // Save current session (store messages snapshot)      
    saveSessionBtn.addEventListener('click', () => {
      if (!activeSession) {
        alert('Create or load a session first (press New).');
        return;
      }
      sessions = sessions.map(s => {
        if (s.id === activeSession) {
          return { ...s, messages: messages.slice(), ts: Date.now() };
        }
        return s;
      });
      saveSessions();
      alert('Session saved locally ‚úì');
      renderSessions();
    });

    // Listen session actions (load/delete)      
    sessionsListEl.addEventListener("click", (ev) => {
      const loadId = ev.target.dataset.load;
      const delId = ev.target.dataset.del;

      if (!loadId && !delId && ev.target.closest('.session-item')) { 
        const sId = ev.target.closest('.session-item').querySelector('[data-load]')?.dataset.load;
        if (sId) {
            const s = sessions.find(x => x.id === sId);
            if (!s) return;
            messages = s.messages ? s.messages.slice() : [];
            saveMessages();
            setActiveSession(sId);
            renderMessages();
            requestAnimationFrame(() => window.scrollTo(0, document.body.scrollHeight));
        }
    }

      if (loadId) {
        const s = sessions.find((x) => x.id === loadId);
        if (!s) return;
        messages = s.messages ? s.messages.slice() : [];
        saveMessages();
        setActiveSession(loadId);
        renderMessages(); 
        setTimeout(() => window.scrollTo(0, document.body.scrollHeight), 50);
        return;
      }

      if (delId) {
        if (!confirm("Delete this session?")) return;
        sessions = sessions.filter((x) => x.id !== delId);
        saveSessions();
        if (activeSession === delId) {
          activeSession = null;
          localStorage.removeItem(STORAGE.activeSessionId);
          messages = [];
          saveMessages();
          chatWindow.innerHTML = "";
        }
        renderSessions();
        return;
      }
    });

    document.getElementById("clearMemoryBtn").addEventListener("click", () => {
      if (!confirm("‚ö†Ô∏è Clear ALL sessions, messages, nodes, and links?")) return;
      localStorage.clear();
      
      nodes = [];
      links = [];
      sessions = [];
      messages = [];
      activeSession = null;

      chatWindow.innerHTML = "";
      renderSessions();
      drawGraph();
      alert("üßπ All MindChat memory cleared!");
    });

    /* -------------- Chat UI -------------- */
    function appendMessage(text, who, ts) {
      const el = document.createElement('div');
      el.className = 'message ' + (who === 'user' ? 'user' : 'ai');
      el.innerHTML = `<div>${escapeHtml(text)}</div><div class="meta">${who === 'user' ? 'You' : 'MindChat AI'} ‚Ä¢ ${new Date(ts).toLocaleTimeString()}</div>`;
      chatWindow.appendChild(el);
      // ‚ö†Ô∏è KEY CHANGE: Scroll the entire window instead of chatWindow
      requestAnimationFrame(() => {
        window.scrollTo(0, document.body.scrollHeight);
      });
    }

    function escapeHtml(s) {
      return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function calculateEmotionalTrend() {
  const recent = messages.slice(-20); // last 20 messages

  if (recent.length === 0) return 0;

  let sum = 0;
  recent.forEach(m => {
    if (typeof m.emotion === "number") sum += m.emotion;
  });

  return sum / recent.length; // -1 to +1
}

// Mood Detection
// -----------------------------
function detectMood(text) {
  const input = text.toLowerCase();

  const moodKeywords = {
    sad: ["sad", "tired", "lonely", "depressed", "hurt", "empty", "down"],
    happy: ["happy", "excited", "great", "joy", "awesome", "good mood"],
    angry: ["angry", "mad", "annoyed", "frustrated", "irritated", "rage"],
    love: ["love", "like", "crush", "heart", "cherish", "admire", "affection"]
  };

  // Check each mood category
  for (const mood in moodKeywords) {
    if (moodKeywords[mood].some(word => input.includes(word))) {
      return mood;
    }
  }

  return "neutral";
}

function computeContextScore(text) {
  const lower = text.toLowerCase();
  let score = 0;

  const boosters = ["really", "very", "so", "too", "extremely"];
  const weakeners = ["maybe", "kind of", "slightly"];

  boosters.forEach(b => { if (lower.includes(b)) score += 0.2; });
  weakeners.forEach(w => { if (lower.includes(w)) score -= 0.1; });

  // Normalize between 0 and 1
  return Math.min(1, Math.max(0, 0.5 + score));
}

// ‚≠ê Paste here
function microReaction(mood, intensity) {
  if (intensity < 0.4) return "";

  const reactions = {
    sad: ["(hugging you softly)", "I'm staying with you üíô"],
    happy: ["(smiling with you)", "Love the energy ‚ú®"],
    angry: ["(taking a breath with you)", "I'm here. It's okay."],
    love: ["(blushing a little)", "Aww that‚Äôs sweet üíû"]
  };

  const group = reactions[mood];
  return group ? group[Math.floor(Math.random() * group.length)] : "";
}

function applyPersonalityTone(text, mood) {
  let t = text;

  if (personality.empathy > 0.7 && (mood === "sad" || mood === "angry")) {
    t = "I feel you deeply‚Ä¶ " + t;
  }

  if (personality.optimism > 0.7 && mood === "sad") {
    t += " But I promise there‚Äôs a tiny light ahead.";
  }

  if (personality.humor > 0.6 && mood === "happy") {
    t += " üòÑ";
  }

  if (personality.reflectiveness > 0.7 && mood === "neutral") {
    t += " Sometimes thoughts open hidden doors.";
  }

  if (personality.warmth > 0.8 && mood === "love") {
    t = "üíó " + t;
  }

  return t;
}

// ‚≠ê Paste here
function updateNodeInfluence(node, intensity) {
  const newWeight = node.weight + intensity * 0.15;
  node.weight = Math.min(1, newWeight);
}

function applyPersonalityToNode(node) {
  let bonus = 0;

  // Warm & Empathetic minds increase weight of emotional messages
  if (personality.empathy > 0.7 && Math.abs(node.emotion) > 0.5) {
    bonus += 0.1;
  }

  // Optimistic minds boost positive clusters
  if (personality.optimism > 0.7 && node.emotion > 0) {
    bonus += 0.08;
  }

  // Reflective personality boosts neutral or deep messages
  if (personality.reflectiveness > 0.6 && node.emotion === 0) {
    bonus += 0.05;
  }

  // Humor boosts happy/light nodes
  if (personality.humor > 0.6 && node.mood === "happy") {
    bonus += 0.04;
  }

  node.weight = Math.min(1, node.weight + bonus);
}


/* ---------------- Personality Mood Drift ---------------- */
let mindchatMood = 0; // -1 = low, +1 = high

function updateMoodDrift(userMood, contextScore) {
  const change = (userMood === "sad" ? -0.1 :
                 userMood === "happy" ? +0.1 :
                 userMood === "love" ? +0.05 :
                 userMood === "angry" ? -0.05 : 0);

  mindchatMood += change * contextScore;
  mindchatMood = Math.max(-1, Math.min(1, mindchatMood));
}

function detectPersonalFact(text) {
  const t = text.toLowerCase();

  // LIKE
  if (t.startsWith("i like "))
    return { type: "like", item: text.slice(7) };

  // LOVE
  if (t.startsWith("i love "))
    return { type: "love", item: text.slice(7) };

  // HATE
  if (t.startsWith("i hate "))
    return { type: "hate", item: text.slice(7) };

  // FAVORITE GENERAL
  if (t.includes("favourite ") || t.includes("favorite ")) {
    const item = text.split(/favourite |favorite /i)[1];

    // Sub-categories
    if (t.includes("place")) return { type: "favorite_place", item };
    if (t.includes("hero")) return { type: "favorite_hero", item };
    if (t.includes("food")) return { type: "favorite_food", item };
    if (t.includes("colour") || t.includes("color")) return { type: "favorite_color", item };
    if (t.includes("movie")) return { type: "favorite_movie", item };
    if (t.includes("song")) return { type: "favorite_song", item };
    if (t.includes("animal")) return { type: "favorite_animal", item };
    if (t.includes("person")) return { type: "favorite_person", item };

    // fallback ‚Äî general favorite
    return { type: "favorite", item };
  }

  return null;
}




function storeFact(item, type) {
  memoryGraph.push({
    node: item.trim(),
    type: type,
    weight: type === "hate" ? -1 : 1,
    timestamp: Date.now()
  });
}



function answerPersonalQuestionV2(text) {
  const t = text.toLowerCase();

  // LIKE
  if (hasAny(t, ["what do i like", "my likes", "things i like", "what i usually like", "remind my likes"])) {
    return topNode("like");
  }

  // LOVE
  if (hasAny(t, ["who do i love", "person i love", "i love who", "who i usually love"])) {
    return topNode("love");
  }

  // HATE
  if (hasAny(t, ["what do i hate", "things i hate", "my hates", "i dislike"])) {
    return topNode("hate");
  }

  // FAVOURITE PLACE
  if (hasAny(t, ["favourite place", "favorite place", "my place", "place i like", "fav place"])) {
    return topNode("place");
  }

  // FAVOURITE HERO
  if (hasAny(t, ["favourite hero", "favorite hero", "my hero", "fav hero"])) {
    return topNode("hero");
  }

  // FAVOURITE MOVIE
  if (hasAny(t, ["favourite movie", "favorite movie", "my movie", "fav movie"])) {
    return topNode("movie");
  }

  // FAVOURITE COLOR
  if (hasAny(t, ["favourite color", "favorite color", "fav color", "colour i like"])) {
    return topNode("color");
  }

  return null;
}


function answerFromMemory(text) {
  const t = text.toLowerCase();

  if (t.includes("what do i like"))
    return getTopMemory("like");

  if (t.includes("who do i love"))
    return getTopMemory("love");

  if (t.includes("what do i hate"))
    return getTopMemory("hate");

  if (t.includes("favourite")) {
    const match = t.match(/favourite (.+)/);
    if (match) return memory.favorite[match[1]] || null;
  }

  return null;
}



function answerFromMemory(query) {
  const q = query.toLowerCase();

  // 1. direct checks
  const personal = answerPersonalQuestion(q);
  if (personal) return personal;

  // 2. fuzzy match
  const scored = memoryGraph
      .map(n => ({
         score: textSimilarity(q, n.node.toLowerCase()),
         node: n.node
      }))
      .filter(x => x.score > 0.3)
      .sort((a, b) => b.score - a.score);

  if (scored.length > 0) return scored[0].node;

  return null;
}



function getTopMemory(type) {
  const list = memory[type];
  if (!list || list.length === 0) return null;

  return list
    .slice()
    .sort((a, b) => b.weight - a.weight)[0]
    .item;
}






function answerFromMemory(query) {
  const q = query.toLowerCase();
  // simple rule checks first (existing)
  const personal = answerPersonalQuestion(q);
  if (personal) return personal;

  // fuzzy search: find nodes with high similarity to query tokens
  const scored = nodes.map(n => ({ id: n.id, score: textSimilarity(q, n.text), node: n }))
                      .filter(x => x.score > 0.2)
                      .sort((a,b)=>b.score - a.score);
  if (scored.length > 0) {
    return scored[0].node.text;
  }

  // fall back
  return null;
}

function archiveOldNodes(days = 180) {
  const cutoff = Date.now() - (days * 24 * 60 * 60 * 1000);
  const archive = JSON.parse(localStorage.getItem('mindchat_archive') || '[]');
  const keep = [];
  nodes.forEach(n => {
    if (n.time && n.time < cutoff) {
      archive.push(n);
    } else {
      keep.push(n);
    }
  });
  nodes = keep;
  localStorage.setItem('mindchat_archive', JSON.stringify(archive));
  saveNodes();
}

function exportFullData() {
  const payload = { nodes, links, messages, groups: JSON.parse(localStorage.getItem('mindchat_groups_v1')||'[]'), archive: JSON.parse(localStorage.getItem('mindchat_archive')||'[]'), ts: Date.now() };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
  // same download logic...
}
function generateAIReply(userText) {
  const mood = detectMood(userText);

  const replies = {
    happy: [
      "I love that energy! Tell me more about what made you smile üòÑ",
      "That‚Äôs wonderful ‚Äî it‚Äôs nice to hear your mood is bright!",
      "Good vibes! What are you most thankful for today?"
    ],
    sad: [
      "I'm here with you. Want to talk about what made you feel this way? ü´Ç",
      "It‚Äôs okay to feel down sometimes ‚Äî what could help you right now?",
      "That sounds heavy‚Ä¶ but you‚Äôre not alone üåô"
    ],
    angry: [
      "I sense frustration ‚Äî want to unpack what triggered it?",
      "It‚Äôs okay to feel angry ‚Äî expressing it helps.",
      "Let‚Äôs slow down and take a breath together. üßò"
    ],
    love: [
      "Aww, that‚Äôs sweet ‚Äî love always makes the world brighter üíû",
      "Who‚Äôs on your mind right now?",
      "That‚Äôs lovely. What do you cherish most about that person?"
    ],
    neutral: [
      "I‚Äôm listening carefully ‚Äî tell me more.",
      "That‚Äôs interesting. How do you feel about it?",
      "I‚Äôm linking this with your last thought in memory üß†"
    ]
  };

  const group = replies[mood] || replies.neutral;

  // Pick a reply without repeating last time
  let reply;
  do {
    reply = group[Math.floor(Math.random() * group.length)];
  } while (reply === lastReply && group.length > 1);

  lastReply = reply;
  lastMood = mood;

  // Emotional trend addon
  const trend = calculateEmotionalTrend();
  let trendNote = "";

  if (trend < -0.3) {
    trendNote = " I also sense your emotional trend is dipping recently‚Ä¶ I'm here with you.";
  } else if (trend > 0.3) {
    trendNote = " You've been sounding brighter lately ‚Äî it‚Äôs nice to see.";
  } else if (Math.abs(trend) < 0.1 && messages.length > 5) {
    trendNote = " Your emotions seem steady today.";
  }

  return reply + trendNote;
}


function setTyping(on) {
  typingIndicator.style.display = on ? "block" : "none";

  // Auto scroll when typing bubble appears
  if (on) {
    requestAnimationFrame(() => {
      window.scrollTo(0, document.body.scrollHeight);
    });
  }
}


    function addMessage(text, who) {
  const ts = Date.now();
  messages.push({ who, text, ts });
  saveMessages();
  appendMessage(text, who, ts);
  addNodeToGraph(text, who, ts);
}


function addNodeToGraph(text, who, ts) {
  nodes.push({
    id: uid("node"),
    text,
    who,
    time: ts,
    weight: 0.5,
    emotion: 0,
    importance: 0.5
  });

  saveNodes();
  drawGraph && drawGraph(); // if exists
}
/****************** Natural Memory Extractor (NME) v0.9 ******************/

// Categories we support and keyword sets (loose forms)
const NME_KEYWORDS = {
  like:     ["like", "likes", "fav", "favorite", "favourite", "enjoy", "enjoys", "crazy for", "i'm into", "im into", "my fav"],
  love:     ["love", "loves", "i love", "i'm in love", "im in love", "adore"],
  hate:     ["hate", "hates", "can't stand", "cant stand", "dislike", "dislikes", "worst"],
  place:    ["place", "spot", "location", "area", "my place", "hangout"],
  movie:    ["movie", "film", "cinema"],
  hero:     ["hero", "actor", "star", "idol"],
  color:    ["color", "colour", "shade"],
  food:     ["food", "dish", "cuisine"],
  song:     ["song", "track"],
  person:   ["person", "human", "someone"]
};

// Primary category keys we will store
const NME_CATEGORIES = ["like","love","hate","place","movie","hero","color","food","song","person"];

// memory store (category -> { item: weight })
if (!window.NME_memory) {
  window.NME_memory = JSON.parse(localStorage.getItem('mindchat_NME_memory_v1') || "{}");
  // ensure keys exist
  NME_CATEGORIES.forEach(k => { if (!window.NME_memory[k]) window.NME_memory[k] = {}; });
}

// persist memory
function NME_save() {
  localStorage.setItem('mindchat_NME_memory_v1', JSON.stringify(window.NME_memory));
}

// small normalize helper
function NME_norm(s) {
  if (!s) return '';
  return s.trim().toLowerCase().replace(/["'.,!?;:()]/g, '').replace(/\s+/g, ' ');
}

/* Levenshtein distance for fuzzy matching */
function levenshtein(a, b) {
  a = a || ''; b = b || '';
  const m = a.length, n = b.length;
  if (m === 0) return n;
  if (n === 0) return m;
  const dp = Array.from({length: m+1}, (_,i) => new Array(n+1).fill(0));
  for (let i=0;i<=m;i++) dp[i][0] = i;
  for (let j=0;j<=n;j++) dp[0][j] = j;
  for (let i=1;i<=m;i++){
    for (let j=1;j<=n;j++){
      const cost = a[i-1] === b[j-1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[m][n];
}

/* fuzzy similarity score 0..1 */
function fuzzyScore(a, b) {
  a = NME_norm(a); b = NME_norm(b);
  if (!a || !b) return 0;
  const ld = levenshtein(a, b);
  const maxLen = Math.max(a.length, b.length);
  if (maxLen === 0) return 1;
  return 1 - (ld / maxLen);
}

/* find best existing match in a category (threshold default 0.7) */
function NME_fuzzyMatchExisting(category, candidate, threshold = 0.72) {
  candidate = NME_norm(candidate);
  const pool = window.NME_memory[category] || {};
  let best = null;
  let bestScore = 0;
  for (const item in pool) {
    const s = fuzzyScore(item, candidate);
    if (s > bestScore) { best = item; bestScore = s; }
  }
  if (bestScore >= threshold) return best;
  return null;
}

/* extract candidate phrase from text given an index of keyword */
function NME_extractAfterKeyword(text, keywordIndex, keywordLen) {
  // choose substring after keyword
  const after = text.slice(keywordIndex + keywordLen).trim();
  if (!after) return null;
  // truncate at common stopwords (like "because", "but", "and")
  const stop = after.search(/\b(because|but|and|so|that|which|who|when|where)\b/);
  const chunk = stop === -1 ? after : after.slice(0, stop);
  // take first 5 words as candidate
  return chunk.split(/\s+/).slice(0, 6).join(' ').replace(/^is\s+/,'').trim();
}

/* main extractor: returns {category, item} or null */
function NME_extractMemory(text) {
  if (!text) return null;
  let s = text.toLowerCase().replace(/\s+/g,' ').trim();

  // if short forms like "pizza fav" or "pizza is my fav"
  // try patterns: "<item> fav", "<item> favourite", "<item> is my fav"
  const shortFav = s.match(/(.{1,60})\s+(?:fav|favorite|favourite)$/i);
  if (shortFav) {
    return { category: 'like', item: shortFav[1].trim() };
  }
  const shortLove = s.match(/(.{1,60})\s+(?:love|loves)$/i);
  if (shortLove) return { category: 'love', item: shortLove[1].trim() };

  // iterate keywords for categories
  for (const cat in NME_KEYWORDS) {
    for (const kw of NME_KEYWORDS[cat]) {
      const idx = s.indexOf(kw);
      if (idx !== -1) {
        // candidate after keyword like "i love ariana", "my favourite place is charminar"
        let candidate = NME_extractAfterKeyword(s, idx, kw.length);
        // sometimes phrase is "pizza is my fav" -> find "is my fav" then look left for item
        if (!candidate) {
          // look for patterns like "X is my favourite", "X is my fav"
          const leftMatch = s.match(/(.{1,60})\s+is\s+(?:my\s+)?(?:fav|favorite|favourite|love|loves|hate)/i);
          if (leftMatch) candidate = leftMatch[1].trim();
        }
        if (!candidate) continue;

        // cleanup candidate
        candidate = candidate.replace(/^(is|the|a)\s+/,'').trim();
        if (candidate.length === 0) continue;

        // determine canonical category (map some keyword groups to our store categories)
        let category = cat;
        // normalize specific mapping
        if (cat === 'food') category = 'food';
        if (cat === 'like' && kw.includes('fav')) category = 'like';
        if (cat === 'love') category = 'love';
        if (cat === 'hate') category = 'hate';

        // further refine if contains subwords (movie, hero, color, place)
        if (/movie|film|cinema/.test(candidate) && !['movie'].includes(category)) {
          candidate = candidate.replace(/\b(movie|film|cinema)\b/,'').trim();
          category = 'movie';
        }

        // final normalized item
        const item = candidate.split(/[.?!,;]/)[0].trim();
        if (item) return { category, item: item };
      }
    }
  }

  // fallback: try "my favourite X is Y" pattern (explicit)
  const favPattern = text.match(/my\s+(favorite|favourite)\s+(place|movie|hero|color|colour|food|song|person)?\s*(?:is|:|-)?\s*(.+)/i);
  if (favPattern) {
    let sub = favPattern[2] ? favPattern[2].toLowerCase() : null;
    let val = favPattern[3] ? favPattern[3].trim() : null;
    if (val) {
      // map sub to category
      let cat = 'favorite';
      if (sub === 'place') cat = 'place';
      else if (sub === 'movie' || sub === 'film') cat = 'movie';
      else if (sub === 'hero') cat = 'hero';
      else if (sub === 'color' || sub === 'colour') cat = 'color';
      else if (sub === 'food') cat = 'food';
      else if (sub === 'song') cat = 'song';
      else if (sub === 'person') cat = 'person';
      return { category: cat, item: val };
    }
  }

  return null;
}

/* store memory into NME_memory with weight boosting and fuzzy merge */
function NME_store(category, item) {
  if (!category || !item) return null;

  category = category.toLowerCase();
  if (!NME_CATEGORIES.includes(category) && !NME_CATEGORIES.includes(category.replace(/^favorite_?/,'favorite'))) {
    // fallback map: map 'favorite' variants to 'like' for simplicity
    if (category.startsWith('favorite')) category = 'like';
    if (!NME_CATEGORIES.includes(category)) category = 'like';
  }

  const cleaned = NME_norm(item);

  // fuzzy match existing in this category (use threshold 0.72)
  const matched = NME_fuzzyMatchExisting(category, cleaned, 0.72);
  const finalKey = matched || cleaned;

  // increment weight
  const bucket = window.NME_memory[category] || (window.NME_memory[category] = {});
  bucket[finalKey] = (bucket[finalKey] || 0) + 1; // increment by 1 per mention

  // small cap for sanity
  if (bucket[finalKey] > 100) bucket[finalKey] = 100;

  // save
  window.NME_memory[category] = bucket;
  NME_save();

  return { category, item: finalKey, weight: bucket[finalKey] };
}

/* recall highest-weight item for a category or fuzzy search across categories */
function NME_recallQuestion(query) {
  if (!query) return null;
  const q = query.toLowerCase();

  // direct question mapping
  if (q.includes("what do i like") || q.includes("what are my likes") || q.includes("what do i enjoy"))
    return NME_top('like');

  if (q.includes("who do i love") || q.includes("what do i love") || q.includes("what are my loves"))
    return NME_top('love');

  if (q.includes("what do i hate") || q.includes("what are my hates"))
    return NME_top('hate');

  if (q.includes("what is my favourite place") || q.includes("what is my favorite place") || q.includes("favourite place"))
    return NME_top('place');

  if (q.includes("what is my favourite movie") || q.includes("favorite movie"))
    return NME_top('movie');

  if (q.includes("what is my favourite hero") || q.includes("favorite hero") || q.includes("who is my favourite hero"))
    return NME_top('hero');

  if (q.includes("what is my favourite color") || q.includes("favorite color") || q.includes("what color do i like"))
    return NME_top('color');

  // otherwise fuzzy search across all categories
  let best = { score: 0, category: null, item: null };
  for (const cat of Object.keys(window.NME_memory)) {
    for (const key of Object.keys(window.NME_memory[cat])) {
      const s = fuzzyScore(q, key);
      if (s > best.score) { best.score = s; best.category = cat; best.item = key; }
    }
  }
  if (best.score > 0.45) return best.item;

  return null;
}

/* return the top item in a category (highest weight) */
function NME_top(category) {
  const bucket = window.NME_memory[category] || {};
  const items = Object.entries(bucket);
  if (!items || items.length === 0) return null;
  items.sort((a,b) => b[1] - a[1]);
  return items[0][0]; // item text
}

/* helper to expose memory (for debug / UI) */
function NME_dump() {
  return JSON.parse(JSON.stringify(window.NME_memory));
}

/* integrate into send flow: call this to process incoming user text */
function NME_processInput(text) {
  const t = text.toLowerCase().trim();

  // ------------------------------
  // 1. LIKES / LOVES / HATES
  // ------------------------------
  if (t.startsWith("i like ")) {
    const item = text.slice(7).trim();
    NME_store("like", item);
    return { action: "stored", res: { type: "like", item } };
  }

  if (t.startsWith("i love ")) {
    const item = text.slice(7).trim();
    NME_store("love", item);
    return { action: "stored", res: { type: "love", item } };
  }

  if (t.startsWith("i hate ")) {
    const item = text.slice(7).trim();
    NME_store("hate", item);
    return { action: "stored", res: { type: "hate", item } };
  }

  // ------------------------------
  // 2. FAVOURITE THINGS (place, movie, color, hero)
  // ------------------------------
  const favPatterns = [
    { key: "place", pattern: /favour?ite place is (.+)/i },
    { key: "movie", pattern: /favour?ite movie is (.+)/i },
    { key: "color", pattern: /favour?ite colou?r is (.+)/i },
    { key: "hero",  pattern: /favour?ite hero is (.+)/i }
  ];

  for (const fav of favPatterns) {
    const match = t.match(fav.pattern);
    if (match) {
      const item = match[1].trim();
      NME_store(fav.key, item);
      return { action: "stored", res: { type: fav.key, item } };
    }
  }

  // ------------------------------
  // 3. Recall Questions
  // ------------------------------
  if (t.includes("what do i like")) {
    return { action: "recall", item: NME_recallOne("like") };
  }
  if (t.includes("who do i love")) {
    return { action: "recall", item: NME_recallOne("love") };
  }
  if (t.includes("what do i hate")) {
    return { action: "recall", item: NME_recallOne("hate") };
  }
  if (t.includes("favourite place")) {
    return { action: "recall", item: NME_recallOne("place") };
  }
  if (t.includes("favourite movie")) {
    return { action: "recall", item: NME_recallOne("movie") };
  }
  if (t.includes("favourite color")) {
    return { action: "recall", item: NME_recallOne("color") };
  }
  if (t.includes("favourite hero")) {
    return { action: "recall", item: NME_recallOne("hero") };
  }

  return { action: "none" };
}

// STORAGE
function NME_store(type, item) {
  memoryGraph.push({
    type,
    item,
    weight: 1,
    ts: Date.now()
  });
  localStorage.setItem("memoryGraph", JSON.stringify(memoryGraph));
}

// RECALL
function NME_recallOne(type) {
  const list = memoryGraph.filter(x => x.type === type);
  if (list.length === 0) return "I don't know yet.";
  return list.sort((a,b)=>b.weight-a.weight)[0].item;
}


/****************** END NME v0.9 ******************/




/****************** END NME v0.9 ******************/


/* ------------- Message send flow ------------- */
/* ------------- Message send flow (fixed & integrated) ------------- */
/* ------------- FIXED FULL MESSAGE FLOW (v0.9) ------------- */

/* ------------------ Step-1: Natural Fact Extraction (messy input) ------------------ */

// small helper: remove emojis, punctuation, extra spaces, normalize repeated letters
function normalizeText(s) {
  if (!s || typeof s !== 'string') return '';
  // remove emojis and most symbols
  let t = s.normalize('NFKD').replace(/[\u{1F300}-\u{1F6FF}\u{1F900}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu, ' ');
  // replace punctuation with space
  t = t.replace(/[^a-z0-9\s]/gi, ' ');
  // collapse multiple spaces
  t = t.replace(/\s+/g, ' ').trim();
  // collapse repeated character runs (loose) e.g., pizzzaaa -> pizza
  t = t.replace(/([a-z])\1{2,}/gi, '$1$1'); // keep up to two repeated chars
  return t.toLowerCase();
}

// simple token overlap similarity
function textSimilarity(a, b) {
  if (!a || !b) return 0;
  const A = new Set(a.split(/\s+/).filter(Boolean));
  const B = new Set(b.split(/\s+/).filter(Boolean));
  if (A.size === 0 || B.size === 0) return 0;
  let inter = 0;
  A.forEach(x => { if (B.has(x)) inter++; });
  return inter / Math.max(A.size, B.size);
}

function fuzzyClean(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, "")         // remove symbols
    .replace(/\s+/g, " ")                // normalize spaces
    .trim();
}


// fuzzy-correct an extracted item against existing memory items
function fuzzyCorrectItem(item) {
  // if item is falsy or not a string, return it unchanged (caller will handle nulls)
  if (!item || typeof item !== 'string') return item;
  const cand = item.toLowerCase().trim();
  if (!cand) return item;

  let best = { key: null, score: 0.0 };
  for (const m of (memoryGraph || [])) {
    if (!m || !m.node) continue;
    const score = textSimilarity(cand, m.node.toLowerCase());
    if (score > best.score) {
      best = { key: m.node, score };
    }
  }
  // If a good match is found, return canonical stored value, else return original item
  return best.score > 0.5 ? best.key : item;
}


// categories dictionary: keywords -> normalized category id
const CATEGORY_KEYWORDS = {
  like: ["i like", "like", "i'm into", "im into", "i m into", "i'm a fan of", "i am into", "i enjoy", "enjoy", "my fav", "my favourite", "favorite", "favourite", "fave", "crazy for", "big fan of", "into"],
  love: ["i love", "love", "luv", "i'm in love with", "i am in love with", "adore"],
  hate: ["i hate", "hate", "dont like", "don't like", "can't stand", "cant stand", "hate it", "worst"],
  place: ["place", "spot", "location", "area", "city", "town", "my spot", "my place"],
  hero: ["hero", "actor", "star", "idol"],
  movie: ["movie", "film", "cinema"],
  color: ["color", "colour", "shade"],
  food: ["food", "dish", "meal", "cuisine"],
  song: ["song", "track"],
  person: ["person", "someone", "friend"],
  // fallback generic "favorite" to capture "favorite X"
  favorite: ["favorite", "favourite", "fav"]
};

// try to guess category by scanning the text for keywords
function guessCategoryFromText(t) {
  for (const cat of Object.keys(CATEGORY_KEYWORDS)) {
    for (const kw of CATEGORY_KEYWORDS[cat]) {
      if (t.includes(kw)) return cat;
    }
  }
  return null;
}

// extract probable item phrase given the sentence and guessed category
function extractItemFromPhrase(origText, cat) {
  const text = normalizeText(origText);
  // common patterns to try: "i like X", "my favourite X is Y", "X is my fav", "i love X", "love X"
  // we'll try multiple regex patterns (case-insensitive) on the normalized text
  const patterns = [
    /(?:i like|i love|i luv|i hate|i enjoy|im into|i'm into)\s+(.{1,80})$/,       // "i like pizza"
    /(?:my favourite|my favorite|my fav|favorite|favourite)\s+(?:place|movie|hero|song|color|food|person)?\s*(?:is|:|-)?\s*(.{1,80})$/, // "my favourite place is X"
    /(.{1,80})\s+(?:is my fav|is my favorite|is my favourite|is my spot|is my place)$/, // "pizza is my fav"
    /(.{1,80})\s+(?:is my favourite|is my favorite|is my hero)$/, // "bahubali is my favourite movie"
    /(?:my)\s+(?:best|fav|favourite)\s+(?:movie|place|hero|color)?\s*(?:is)?\s*(.{1,80})$/, // "my best movie bahubali"
    /(?:favorite|favourite)\s+(.{1,80})$/, // "favorite pizza"
    /(?:i'm crazy for|im crazy for|crazy for)\s+(.{1,80})$/, // "crazy for pizza"
    /(?:i'm a fan of|im a fan of|a fan of)\s+(.{1,80})$/ // "a fan of ariana grande"
  ];

  for (const p of patterns) {
    const m = text.match(p);
    if (m && m[1]) {
      const extracted = m[1].trim();
      // remove trailing words that are category keywords (like "place", "movie") if present
      const cleaned = extracted.replace(/\b(place|movie|hero|song|color|food|person|spot|city|town)\b/gi, '').trim();
      return cleaned;
    }
  }

  // fallback: if category is known, try to pull a noun-like phrase after the keyword
  if (cat) {
    for (const kw of CATEGORY_KEYWORDS[cat]) {
      if (text.includes(kw)) {
        const parts = text.split(kw);
        if (parts[1]) {
          const candidate = parts[1].trim().split(/\s{0,1}is\s{0,1}|\s{0,1}:-\s{0,1}/i)[0].trim();
          if (candidate) return candidate;
        }
      }
    }
  }

  // last fallback: take last 3 words (useful for short inputs like "pizza fav")
  const toks = text.split(/\s+/).filter(Boolean);
  if (toks.length <= 3) return toks.join(' ');
  return toks.slice(-3).join(' ');
}

// // core detection function (returns {type,item} or null)
function detectPersonalFactV2(rawText) {
  if (!rawText || typeof rawText !== 'string' || rawText.trim().length === 0) return null;

  const tNorm = normalizeText(rawText);
  // quick rejection: if looks like a question (we only want facts here)
  const isQuestion = /^(what|who|where|when|how|why)\b/i.test(rawText.trim()) || rawText.trim().endsWith('?');
  if (isQuestion) return null;

  // guess category from normalized text
  let cat = guessCategoryFromText(tNorm);

  // try to extract a candidate phrase (may be undefined/null)
  let extracted = extractItemFromPhrase(rawText, cat);
  if (!extracted || typeof extracted !== 'string') {
    // fallback: try to use the last few tokens from normalized text
    const toks = tNorm.split(/\s+/).filter(Boolean);
    extracted = toks.length ? toks.slice(-3).join(' ') : null;
  }

  if (!extracted || extracted.trim().length === 0) return null;

  // normalize extracted item
  const normalizedItem = normalizeText(extracted || '');
  if (!normalizedItem) return null;

  // If category was a generic "favorite", refine using words in the normalized text
  if (cat === 'favorite') {
    if (/\b(place|spot|city|town|location)\b/.test(tNorm)) cat = 'place';
    else if (/\b(hero|actor|star)\b/.test(tNorm)) cat = 'hero';
    else if (/\b(movie|film|cinema)\b/.test(tNorm)) cat = 'movie';
    else if (/\b(color|colour|shade)\b/.test(tNorm)) cat = 'color';
    else if (/\b(song|track)\b/.test(tNorm)) cat = 'song';
  }

  // canonicalize to our short types
  const TYPE_MAP = {
    like: 'like',
    love: 'love',
    hate: 'hate',
    place: 'place',
    hero: 'hero',
    movie: 'movie',
    color: 'color',
    food: 'food',
    song: 'song',
    person: 'person'
  };

const finalType = TYPE_MAP[cat] || (tNorm.includes('like') ? 'like' : null) || (tNorm.includes('love') ? 'love' : null);

 if (!finalType) return null;

  // fuzzy-correct item against existing memoryGraph (safe)
  const corrected = fuzzyCorrectItem(normalizedItem) || normalizedItem;

  return { type: finalType, item: corrected };
}

function detectPersonalFactV2(text) {
  const t = text.toLowerCase();

  if (t.includes("i like")) {
    return { type: "like", item: fuzzyClean(text.split("i like")[1]) };
  }

  if (t.includes("i love")) {
    return { type: "love", item: fuzzyClean(text.split("i love")[1]) };
  }

  if (t.includes("i hate")) {
    return { type: "hate", item: fuzzyClean(text.split("i hate")[1]) };
  }

  if (t.includes("favourite place") || t.includes("favorite place")) {
    return { type: "place", item: fuzzyClean(text.split("place")[1]) };
  }

  if (t.includes("favourite hero") || t.includes("favorite hero")) {
    return { type: "hero", item: fuzzyClean(text.split("hero")[1]) };
  }

  if (t.includes("favourite movie") || t.includes("favorite movie")) {
    return { type: "movie", item: fuzzyClean(text.split("movie")[1]) };
  }

  if (t.includes("favourite color") || t.includes("favorite color")) {
    return { type: "color", item: fuzzyClean(text.split("color")[1]) };
  }

  return null;
}



/* ------------------ Safe: Fact extraction + storage (patched) ------------------ */

// fuzzy-correct an extracted item against existing memory items (safe)

/* ------------------ Safe: Fact extraction + storage (patched) ------------------ */

// fuzzy-correct an extracted item against existing memory items (safe)
function fuzzyCorrectItem(item) {
  // keep original if not a string
  if (!item || typeof item !== "string") return item || "";
  const cand = item.toLowerCase();
  let best = { key: null, score: 0.0 };

  // ensure memoryGraph is an array
  if (!Array.isArray(memoryGraph)) memoryGraph = [];

  for (const m of memoryGraph) {
    // guard m.node
    if (!m || !m.node) continue;
    const score = textSimilarity(cand, String(m.node).toLowerCase());
    if (score > best.score) {
      best = { key: m.node, score };
    }
  }
  // if found good match, return canonical; else return original item
  return best.score > 0.5 ? best.key : item;
}

// core detection function (returns {type,item} or null)
// robust: ensures no undeclared references and checks every variable
function detectPersonalFactV2(rawText) {
  if (!rawText || typeof rawText !== 'string' || rawText.trim().length === 0) return null;

  // normalize + quick guards
  const tNorm = normalizeText(rawText);
  if (!tNorm) return null;

  // quick rejection: question-like (we only extract facts)
  const trimmed = rawText.trim();
  const isQuestion = /^(what|who|where|when|how|why)\b/i.test(trimmed) || trimmed.endsWith('?');
  if (isQuestion) return null;

  // guess category (may be null)
  let cat = guessCategoryFromText(tNorm); // expects lower-cased normalized text

  // try extraction
  const extractedRaw = extractItemFromPhrase(rawText, cat); // may return string or null
  if (!extractedRaw || typeof extractedRaw !== 'string') return null;

  // normalize extracted item safely
  const normalizedItem = normalizeText(extractedRaw || '');
  if (!normalizedItem) return null;

  // fix category when it's ambiguous "favorite"
  if (cat === 'favorite') {
    if (/\b(place|spot|city|town|location)\b/.test(tNorm)) cat = 'place';
    else if (/\b(hero|actor|star)\b/.test(tNorm)) cat = 'hero';
    else if (/\b(movie|film|cinema)\b/.test(tNorm)) cat = 'movie';
    else if (/\b(color|colour|shade)\b/.test(tNorm)) cat = 'color';
    else if (/\b(song|track)\b/.test(tNorm)) cat = 'song';
  }

  // canonicalize
  const TYPE_MAP = {
    like: 'like',
    love: 'love',
    hate: 'hate',
    place: 'place',
    hero: 'hero',
    movie: 'movie',
    color: 'color',
    food: 'food',
    song: 'song',
    person: 'person'
  };

  const finalType = TYPE_MAP[cat] || (tNorm.includes('like') ? 'like' : (tNorm.includes('love') ? 'love' : null));
  if (!finalType) return null;

  // fuzzy-correct item against existing memory (safe)
  const corrected = fuzzyCorrectItem(normalizedItem);

  // return canonical pair (use corrected or normalized)
  return { type: finalType, item: (corrected && typeof corrected === 'string') ? corrected.trim() : normalizedItem.trim() };
}

// improved storeFact (merges duplicates, increases weight) - safe
function storeFactV2(item, type) {
  const clean = item.trim().toLowerCase();

  if (!clean) return;

  const existing = memoryGraph.find(m => m.node === clean && m.type === type);

  if (existing) {
    existing.weight += 1;                // BOOST weight if repeated
    existing.timestamp = Date.now();
  } else {
    memoryGraph.push({
      node: clean,
      type: type,
      weight: 1,
      timestamp: Date.now()
    });
  }
}



function detectAndStoreFact(text) {

  // 1. strict detection (already working)
  if (detectPersonalFact(text)) return true;

  // 2. messy normalization
  const norm = normalizeFact(text);
  if (!norm) return false;

  if (norm.type === "favorite") {
    storeFavorite(norm.category, norm.value);
  } else {
    store(norm.type, norm.value);
  }

  return true;
}

function store(type, value) {
  value = value.trim();

  const list = memory[type];
  const found = list.find(x => x.item === value);

  if (found) {
    found.weight += 1;
  } else {
    list.push({ item: value, weight: 1 });
  }
}

function storeFavorite(category, value) {
  memory.favorite[category] = value.trim();
}

function normalizeFact(text) {
  const t = text.toLowerCase();

  // like patterns
  if (t.match(/(i\s+)?(kinda\s+)?like\s+(.+)/))
    return { type: "like", value: RegExp.$3 };

  if (t.match(/(.+)\s+is\s+my\s+fav/))
    return { type: "like", value: RegExp.$1 };

  // love patterns
  if (t.match(/(i\s+)?love\s+(.+)/))
    return { type: "love", value: RegExp.$2 };

  // hate patterns
  if (t.match(/(i\s+)?hate\s+(.+)/))
    return { type: "hate", value: RegExp.$2 };

  // favorite patterns
  if (t.match(/(.+)\s+is\s+my\s+favorite\s+(.+)/))
    return { type: "favorite", category: RegExp.$2, value: RegExp.$1 };

  if (t.match(/my\s+favorite\s+(.+)\s+is\s+(.+)/))
    return { type: "favorite", category: RegExp.$1, value: RegExp.$2 };

  return null;
}



function sendMessage(text) {

  // 1. Try storing fact
  if (detectAndStoreFact(text)) {
    reply("Got it ‚Äî I remembered that üëç");
    return;
  }

  // 2. Try memory recall
  const memoryReply = answerFromMemory(text);
  if (memoryReply) {
    reply(memoryReply);
    return;
  }

  // 3. Fallback
  reply("Tell me more üôÇ");
}

async function sendMessage() {
  const text = userInput.value.trim();
  if (!text) return;

  const ts = Date.now();

  // Save user message
  messages.push({ who: 'user', text, ts });
  saveMessages();
  appendMessage(text, 'user', ts);
  addNodeToGraph(text, 'user', ts);
  userInput.value = '';

  const recall = recallFromMemory(text);

if (recall && recall !== "I don't know yet.") {
  reply = recall;
} else {
  reply = generateAIReply(text);
}

  const nme = NME_processInput(text);
    if (nme.action === 'stored') {
      addMessage(`Got it ‚Äî I remembered "${nme.res.item}".`, 'ai');
      return;
    }
    if (nme.action === 'recall') {
      addMessage(nme.item, 'ai');
      return;
    }




  // Show typing immediately
  setTyping(true);

  // AI reply delay
  const delay = 600 + Math.floor(Math.random() * 600);

  clearTimeout(typingTimeout);

  typingTimeout = setTimeout(() => {

    // ------------------------------
    // 1. Detect mood & context
    // ------------------------------
    const mood = detectMood(text);
    const contextScore = computeContextScore(text);



    // ------------------------------
    // 3. Try memory answer first
    // ------------------------------
  let memoryAnswer = answerPersonalQuestionV2(text);
if (memoryAnswer) {
    appendMessage(memoryAnswer, "ai", Date.now());
    setTyping(false);
    return;
}

    // ------------------------------
    // 2. Store personal facts
    // ------------------------------
const fact = detectPersonalFactV2(text);
if (fact && !text.includes("?")) {   // üí• prevents ‚Äútell me my likes‚Äù
    storeFact(fact.item, fact.type);
    appendMessage("Got it ‚Äî I remembered \"" + fact.item + "\".", "ai", Date.now());
    return;
}


    // ------------------------------
    // 4. If memoryAnswer exists ‚Üí use it
    // ------------------------------
    let thought;

    if (memoryAnswer) {
      // Example: User asks "what is my favourite place?"
      thought = memoryAnswer;
    } else {
      // No memory match ‚Üí generate emotional + context reply
      thought = generateReply(text, mood);
    }

    // ------------------------------
    // 5. Apply personality tone
    // ------------------------------
    thought = applyPersonalityTone(thought, mood);

    // ------------------------------
    // 6. Add micro-reaction
    // ------------------------------
    const reaction = microReaction(mood, contextScore);
    const finalReply = (reaction ? reaction + " " : "") + thought;

    // ------------------------------
    // 7. Update mood drift
    // ------------------------------
    updateMoodDrift(mood, contextScore);

    // ------------------------------
    // 8. Strengthen graph nodes
    // ------------------------------
    nodes.forEach(n => applyPersonalityToNode(n));

    // ------------------------------
    // 9. Save AI message
    // ------------------------------
    const ts2 = Date.now();
    messages.push({ who: 'ai', text: finalReply, ts: ts2 });
    saveMessages();
    appendMessage(finalReply, 'ai', ts2);
    addNodeToGraph(finalReply, 'ai', ts2);

    // Hide typing now
    setTyping(false);

  }, delay);
}



sendBtn.addEventListener('click', sendMessage);
userInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.ctrlKey) {
        sendMessage();
    }
});


    /* ---------------- Graph logic (Emotional Layer) ---------------- */
    
    function analyzeEmotion(text) {
      const positive = ['love', 'happy', 'joy', 'beautiful', 'great', 'like', 'peace', 'calm', 'hope', 'smile', 'excited', 'wonderful'];
      const negative = ['sad', 'hate', 'angry', 'pain', 'cry', 'fear', 'bad', 'hurt', 'lonely', 'tired', 'mad', 'annoyed', 'frustrated'];
      let score = 0;
      text.toLowerCase().split(/\s+/).forEach(w => {
        if (positive.includes(w)) score += 1;
        if (negative.includes(w)) score -= 1;
      });
      return Math.max(-3, Math.min(3, score));
    }
    
    const STOP = new Set(['the', 'and', 'a', 'i', 'to', 'of', 'in', 'on', 'for', 'is', 'it', 'that', 'this', 'with', 'my', 'you', 'me', 'be', 'im', 'am']);
    function extractKeywords(text) {
      return text.toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .split(/\s+/)
        .filter(w => w.length > 2 && !STOP.has(w))
        .slice(0, 6);
    }

    function detectRepetition(text) {
  const t = text.toLowerCase();
  let count = 0;

  nodes.forEach(n => {
    if (n.text.toLowerCase().includes(t.slice(0, 12))) {
      count++;
    }
  });

  return Math.min(count / 4, 1); // more repetition = more importance
}

function detectRecallIntent(text) {
  const t = text.toLowerCase();

  if (t.includes("like")) return { type: "like" };
  if (t.includes("love")) return { type: "love" };
  if (t.includes("hate")) return { type: "hate" };

  // favorites
  if (t.includes("place")) return { type: "favorite", category: "place" };
  if (t.includes("color")) return { type: "favorite", category: "color" };
  if (t.includes("movie")) return { type: "favorite", category: "movie" };
  if (t.includes("hero")) return { type: "favorite", category: "hero" };

  return null;
}


function computeImportance(text, emotionScore) {
  const lengthScore = Math.min(text.length / 120, 1);   // up to +1
  const repeatScore = detectRepetition(text);           // 0 ‚Üí 1
  const emotionalScore = Math.abs(emotionScore) / 3;    // 0 ‚Üí 1

  let baseImportance = (lengthScore * 0.3) +
                       (emotionalScore * 0.5) +
                       (repeatScore * 0.2);

  return Math.min(1, baseImportance);
}


function recallFromMemory(text) {
  const intent = detectRecallIntent(text);
  if (!intent) return null;

  if (intent.type === "favorite") {
    return favoriteOf(intent.category);
  }

  return topMemory(intent.type);
}


    
    function addNodeToGraph(text, type, ts) {
      const emotion = analyzeEmotion(text);
      const KW = extractKeywords(text);
      const x = 30 + Math.random() * (graphCanvas.width - 60);
      const y = 30 + Math.random() * (graphCanvas.height - 60);
      
      const hueShift = 240 + (emotion * 20); 
      const nodeColor = `hsl(${hueShift}, 85%, 55%)`;
      
      const node = { 
  id: uid('n'),
  text, 
  ts, 
  x, 
  y, 
  color: nodeColor, 
  dx: (Math.random() - .5) * 1.2, 
  dy: (Math.random() - .5) * 1.2, 
  keywords: KW, 
  emotion,

  // üü£ NEW FIELDS START
  emotionLabel: detectMood(text),     // e.g., "sad", "happy", "angry", "love", "neutral"
  importance: computeImportance(text, emotion),
  time: Date.now(),                   // memory timestamp
  // üü£ NEW FIELDS END
};

      const matches = nodes.filter(n => n.keywords.some(k => KW.includes(k)));
      const toLink = matches.slice(-3);
      nodes.push(node);
      toLink.forEach(m => links.push({ a: m.id, b: node.id }));
      
      if (toLink.length === 0 && nodes.length > 1) {
        links.push({ a: nodes[nodes.length - 2].id, b: node.id });
      }
      saveNodes(); saveLinks();
    }
    
    const clusterCenters = {
  happy: { x: 120, y: 120 },
  sad: { x: 360, y: 120 },
  angry: { x: 240, y: 260 }
};





    /* ---------------- Graph draw + animation ---------------- */
    function drawGraph() {
      ctx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
      

      nodes.forEach(n => {
        n.dx *= 0.99; n.dy *= 0.99;
        n.x += (n.dx || 0);
        n.y += (n.dy || 0);
        
        if (n.x < 12) { n.x = 12; n.dx = Math.abs(n.dx) * 0.9; }
        if (n.x > graphCanvas.width - 12) { n.x = graphCanvas.width - 12; n.dx = -Math.abs(n.dx) * 0.9; }
        if (n.y < 12) { n.y = 12; n.dy = Math.abs(n.dy) * 0.9; }
        if (n.y > graphCanvas.height - 12) { n.y = graphCanvas.height - 12; n.dy = -Math.abs(n.dy) * 0.9; }
        n.importance *= 0.9995;   // slow decay every frame
      });

      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(123,92,255,0.22)';
      links.forEach(l => {
        const a = nodes.find(n => n.id === l.a);
        const b = nodes.find(n => n.id === l.b);
        if (!a || !b) return;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      });

      nodes.forEach(n => {
        ctx.beginPath();
        const intensity = Math.abs(n.emotion || 0);
        const size = 5 + (n.importance * 10);
        ctx.fillStyle = n.color || '#b8a6ff';
        ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
        ctx.fill();
        // ‚îÄ‚îÄ‚îÄ Emotion Cluster Gravity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (n.emotionLabel && clusterCenters[n.emotionLabel]) {
  const center = clusterCenters[n.emotionLabel];

  // Pull node 5% toward its emotion center
  n.x += (center.x - n.x) * 0.05;
  n.y += (center.y - n.y) * 0.05;
}


        if (intensity > 1) {
          const grd = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, size * 2);
          grd.addColorStop(0, n.color.replace(/, 55%\)/, ', 75%)'));
          grd.addColorStop(1, 'transparent');
          ctx.fillStyle = grd;
          ctx.beginPath(); ctx.arc(n.x, n.y, size * 2, 0, Math.PI * 2); ctx.fill();
        }
        
      });

      requestAnimationFrame(drawGraph);
    }

    /* tooltip hover */
    graphCanvas.addEventListener('mousemove', (ev) => {
  const rect = graphCanvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;

  let found = null;

  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    const dx = x - n.x;
    const dy = y - n.y;
    if (Math.sqrt(dx * dx + dy * dy) < 12) { 
      found = n; 
      break; 
    }
  }

  if (found) {

    const moodType = found.emotionLabel || (
      found.emotion > 0 ? "Positive" :
      found.emotion < 0 ? "Negative" :
      "Neutral"
    );

    const intensityPercent = Math.round(Math.abs(found.emotion || 0) * 40);

    const age = Math.floor((Date.now() - found.time) / 1000);
    const ageText = age < 60 ? `${age}s ago`
                 : age < 3600 ? `${Math.floor(age/60)}m ago`
                 : `${Math.floor(age/3600)}h ago`;

    tooltip.style.left = (ev.clientX + 12) + 'px';
    tooltip.style.top = (ev.clientY + 12) + 'px';

    tooltip.innerHTML = `
      Mood: <b>${moodType}</b><br>
      Intensity: <b>${intensityPercent}%</b><br>
      Stored: <b>${ageText}</b><br><br>
      <span style="opacity:0.8;">"${found.text.slice(0, 160)}"</span>
    `;

    tooltip.style.opacity = 1;

  } else {
    tooltip.style.opacity = 0;
  }
});

    /* canvas click: focus message or open detail (optional) */
    graphCanvas.addEventListener('click', (ev) => {
      const rect = graphCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i];
        const dx = x - n.x, dy = y - n.y;
        if (Math.sqrt(dx * dx + dy * dy) < 10) {
          messages.push({ who: 'ai', text: 'I recall this memory: "' + n.text.slice(0, 120) + '"', ts: Date.now() });
          saveMessages();
          appendMessage('I recall this memory: "' + n.text.slice(0, 120) + '"', 'ai', Date.now());
          return;
        }
      }
    });

    /* --------------- Export / clear / save actions --------------- */
    exportBtn.addEventListener('click', () => {
        const lines = messages.map(m => {
          const who = m.who === 'user' ? 'You' : 'MindChat AI';
          return `[${new Date(m.ts).toLocaleString()}] ${who}: ${m.text}`;
        }).join('\n\n');

        if (!lines || messages.length <= 1) {
          alert("No significant messages to export!");
          return;
        }

        const blob = new Blob([lines], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `MindChat_Transcript_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    });

    clearGraphBtn.addEventListener('click', () => {
      if (!confirm('Clear all memory nodes, links, and saved nodes from graph? (This does not affect chat sessions).')) return;
      nodes = []; links = []; saveNodes(); saveLinks();
      alert('Graph Memory cleared.');
    });

    downloadGraphBtn.addEventListener('click', () => {
      const data = { nodes, links, ts: Date.now() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'mindchat_graph_' + (new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')) + '.json';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    saveNodesBtn.addEventListener('click', () => {
      saveNodes(); saveLinks();
      alert('Nodes & links saved to localStorage ‚úì');
    });

    /* -------------- Messages load/render at start -------------- */
    function renderMessages() {
      chatWindow.innerHTML = '';
      if (!messages || messages.length === 0 || !activeSession) {
        const welcomeText = 'Hello üëã I‚Äôm MindChat AI, your memory companion. What‚Äôs on your mind today?';
        messages = [{ who: 'ai', text: welcomeText, ts: Date.now() }];
        if (activeSession) saveMessages(); 
      }
      messages.forEach(m => appendMessage(m.text, m.who, m.ts));
      // ‚ö†Ô∏è KEY CHANGE: Scroll the entire window on load
      setTimeout(() => window.scrollTo(0, document.body.scrollHeight), 100);
    }

    /* -------------- initial render -------------- */
    nodes = nodes.map(n => ({...n, emotion: n.emotion || analyzeEmotion(n.text)})); 
    
    renderSessions();
    if (!activeSession && sessions.length > 0) {
      setActiveSession(sessions[0].id);
    } else if (!activeSession) {
        const defaultSessionId = uid('sess');
        const defaultSession = { id: defaultSessionId, name: 'Default Session', ts: Date.now(), messages: [] };
        sessions.push(defaultSession);
        saveSessions();
        setActiveSession(defaultSessionId);
    }
    function storeMemory(type, value, category = null) {
  value = value.toLowerCase().trim();

  if (type === "favorite") {
    if (!personalMemory.favorite[category]) {
      personalMemory.favorite[category] = { value, weight: 1 };
    } else if (personalMemory.favorite[category].value === value) {
      personalMemory.favorite[category].weight++;
    } else {
      personalMemory.favorite[category] = { value, weight: 1 };
    }
    return;
  }

  const list = personalMemory[type];
  const existing = list.find(i => i.value === value);

  if (existing) {
    existing.weight++;
    existing.lastSeen = Date.now();
  } else {
    list.push({ value, weight: 1, lastSeen: Date.now() });
  }
}
function topMemory(type) {
  const list = personalMemory[type];
  if (!list || list.length === 0) return "I don't know yet.";

  return list.sort((a,b)=>b.weight - a.weight)[0].value;
}
function favoriteOf(category) {
  return personalMemory.favorite[category]?.value || "I don't know yet.";
}

    renderMessages();
    requestAnimationFrame(drawGraph);
  </script>
</body>
</html>
